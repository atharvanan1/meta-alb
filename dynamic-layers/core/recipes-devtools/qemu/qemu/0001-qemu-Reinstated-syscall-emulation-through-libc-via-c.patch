From 9162e3c7c1eb3faa8da250ddf5f910ada47ab636 Mon Sep 17 00:00:00 2001
From: Heinz Wrobel <Heinz.Wrobel@nxp.com>
Date: Fri, 11 Nov 2022 15:48:42 +0200
Subject: [PATCH] qemu: Reinstated syscall emulation through libc via command
 line option.

The problem is that running qemu under pseudo or a LD_PRELOAD based
fakeroot enviroment will fail if the LD_PRELOAD lib can no longer catch
specific system calls. Rather than breaking the fakeroot style chroot
emulation, we permit rerouting specific syscalls again through glibc.
Yes, this is making them "unsafe" in terms of signals again, but it
seems to be the only reasonable way to run qemu user space in a fake
chroot pseudo environment.

Signed-off-by: Heinz Wrobel <Heinz.Wrobel@nxp.com>
Signed-off-by: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Signed-off-by: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
---
 linux-user/main.c           |  7 ++++
 linux-user/syscall.c        | 74 +++++++++++++++++++++++++++++++------
 linux-user/user-internals.h |  1 +
 3 files changed, 71 insertions(+), 11 deletions(-)

diff --git a/linux-user/main.c b/linux-user/main.c
index 16def5215..cc27a4428 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -380,6 +380,11 @@ static void handle_arg_strace(const char *arg)
     enable_strace = true;
 }
 
+static void handle_arg_libcsyscall(const char *arg)
+{
+    do_libcsyscall = 1;
+}
+
 static void handle_arg_version(const char *arg)
 {
     printf("qemu-" TARGET_NAME " version " QEMU_FULL_VERSION
@@ -455,6 +460,8 @@ static const struct qemu_argument arg_table[] = {
      "",           "run in singlestep mode"},
     {"strace",     "QEMU_STRACE",      false, handle_arg_strace,
      "",           "log system calls"},
+    {"libcsyscall","QEMU_LIBCSYSCALL", false, handle_arg_libcsyscall,
+     "",           "run system calls for fakeroot/pseudo through libc"},
     {"seed",       "QEMU_RAND_SEED",   true,  handle_arg_seed,
      "",           "Seed for pseudo-random number generator"},
     {"trace",      "QEMU_TRACE",       true,  handle_arg_trace,
diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 839fc7694..c70253641 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -62,6 +62,7 @@
 #include <linux/in6.h>
 #include <linux/errqueue.h>
 #include <linux/random.h>
+#include <signal.h>
 #ifdef CONFIG_TIMERFD
 #include <sys/timerfd.h>
 #endif
@@ -142,6 +143,8 @@
 #include "fd-trans.h"
 #include "tcg/tcg.h"
 
+int do_libcsyscall = 0;
+
 #ifndef CLONE_IO
 #define CLONE_IO                0x80000000      /* Clone io context */
 #endif
@@ -259,6 +262,22 @@ static type name (type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5,	\
 }
 
 
+#define _libc_syscall1(type,name,namelibc,type1,arg1)  \
+static type name (type1 arg1)        \
+{              \
+	if (do_libcsyscall)       \
+		return namelibc(arg1);      \
+	return syscall(__NR_##name, arg1);    \
+}
+
+#define _libc_syscall3(type,name,namelibc,type1,arg1,type2,arg2,type3,arg3)  \
+static type name (type1 arg1,type2 arg2,type3 arg3)        \
+{                    \
+	if (do_libcsyscall)             \
+		return namelibc(arg1, arg2, arg3);        \
+	return syscall(__NR_##name, arg1, arg2, arg3);        \
+}
+
 #define __NR_sys_uname __NR_uname
 #define __NR_sys_getcwd1 __NR_getcwd
 #define __NR_sys_getdents __NR_getdents
@@ -415,9 +434,17 @@ _syscall2(int, sys_getcwd1, char *, buf, size_t, size)
 
 #if defined(TARGET_NR_utimensat) || defined(TARGET_NR_utimensat_time64)
 #if defined(__NR_utimensat)
-#define __NR_sys_utimensat __NR_utimensat
-_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,
-          const struct timespec *,tsp,int,flags)
+/* utimensat has an awful prototype that passes a structure.
+ * This complicates life if you want to use either libc or the syscall.
+ * We can't use _syscall4() here.
+ */
+static int sys_utimensat(int dirfd, const char *pathname,
+                         const struct timespec times[2], int flags)
+{
+    if (do_libcsyscall)
+        return utimensat(dirfd, pathname, times, flags);
+    return syscall(__NR_utimensat, dirfd, pathname, &times[0], flags);
+}
 #else
 static int sys_utimensat(int dirfd, const char *pathname,
                          const struct timespec times[2], int flags)
@@ -559,6 +586,31 @@ const char *target_strerror(int err)
     return strerror(target_to_host_errno(err));
 }
 
+#define libc_syscallargs(name, ...) \
+( \
+    (do_libcsyscall) ? \
+        name(__VA_ARGS__) \
+    : \
+        safe_syscall(__NR_##name, __VA_ARGS__) \
+)
+
+#define libc_syscall3(type, name, type1, arg1, type2, arg2, type3, arg3) \
+static type safe_##name(type1 arg1, type2 arg2, type3 arg3) \
+{ \
+    if (do_libcsyscall) \
+        return name(arg1, arg2, arg3); \
+    return safe_syscall(__NR_##name, arg1, arg2, arg3); \
+}
+
+#define libc_syscall4(type, name, type1, arg1, type2, arg2, type3, arg3, \
+    type4, arg4) \
+static type safe_##name(type1 arg1, type2 arg2, type3 arg3, type4 arg4) \
+{ \
+    if (do_libcsyscall) \
+        return name(arg1, arg2, arg3, arg4); \
+    return safe_syscall(__NR_##name, arg1, arg2, arg3, arg4); \
+}
+
 #define safe_syscall0(type, name) \
 static type safe_##name(void) \
 { \
@@ -608,7 +660,7 @@ static type safe_##name(type1 arg1, type2 arg2, type3 arg3, type4 arg4, \
 
 safe_syscall3(ssize_t, read, int, fd, void *, buff, size_t, count)
 safe_syscall3(ssize_t, write, int, fd, const void *, buff, size_t, count)
-safe_syscall4(int, openat, int, dirfd, const char *, pathname, \
+libc_syscall4(int, openat, int, dirfd, const char *, pathname, \
               int, flags, mode_t, mode)
 #if defined(TARGET_NR_wait4) || defined(TARGET_NR_waitpid)
 safe_syscall4(pid_t, wait4, pid_t, pid, int *, status, int, options, \
@@ -616,7 +668,7 @@ safe_syscall4(pid_t, wait4, pid_t, pid, int *, status, int, options, \
 #endif
 safe_syscall5(int, waitid, idtype_t, idtype, id_t, id, siginfo_t *, infop, \
               int, options, struct rusage *, rusage)
-safe_syscall3(int, execve, const char *, filename, char **, argv, char **, envp)
+libc_syscall3(int, execve, const char *, filename, char **, argv, char **, envp)
 #if defined(TARGET_NR_select) || defined(TARGET_NR__newselect) || \
     defined(TARGET_NR_pselect6) || defined(TARGET_NR_pselect6_time64)
 safe_syscall6(int, pselect6, int, nfds, fd_set *, readfds, fd_set *, writefds, \
@@ -720,9 +772,9 @@ safe_syscall6(ssize_t, copy_file_range, int, infd, loff_t *, pinoff,
  * This will then work and use a 64-bit offset for both 32-bit and 64-bit hosts.
  */
 #ifdef __NR_fcntl64
-#define safe_fcntl(...) safe_syscall(__NR_fcntl64, __VA_ARGS__)
+#define safe_fcntl(...) libc_syscallargs(fcntl64, __VA_ARGS__)
 #else
-#define safe_fcntl(...) safe_syscall(__NR_fcntl, __VA_ARGS__)
+#define safe_fcntl(...) libc_syscallargs(fcntl, __VA_ARGS__)
 #endif
 
 static inline int host_to_target_sock_type(int host_type)
@@ -6976,10 +7028,10 @@ static inline int tswapid(int id)
 #define __NR_sys_setresgid __NR_setresgid
 #endif
 
-_syscall1(int, sys_setuid, uid_t, uid)
-_syscall1(int, sys_setgid, gid_t, gid)
-_syscall3(int, sys_setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)
-_syscall3(int, sys_setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)
+_libc_syscall1(int, sys_setuid, setuid, uid_t, uid)
+_libc_syscall1(int, sys_setgid, setgid, gid_t, gid)
+_libc_syscall3(int, sys_setresuid, setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)
+_libc_syscall3(int, sys_setresgid, setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)
 
 void syscall_init(void)
 {
diff --git a/linux-user/user-internals.h b/linux-user/user-internals.h
index 661612a08..e6b350e6b 100644
--- a/linux-user/user-internals.h
+++ b/linux-user/user-internals.h
@@ -96,6 +96,7 @@ void probe_guest_base(const char *image_name,
 
 /* syscall.c */
 int host_to_target_waitstatus(int status);
+extern int do_libcsyscall;
 
 #ifdef TARGET_I386
 /* vm86.c */
-- 
2.25.1

